/*

Create a C++ function named CountPermutation that will find the number of permutations. 

In the kingdom of Permutonia, there exists a powerful wizard named Sage Inversius, who is known for his ability to manipulate the order of things. 
The kingdom is home to an array of numbers, ranging from 0 to len−1, which the wizard loves to shuffle into various permutations.

One day, the royal court presented Sage Inversius with a series of challenges, known as the Inversion Requirements. These requirements came in the form of a scroll, where each line dictated a specific condition for the wizard's permutations. Each condition is described as follows:

Requirement[i] states that the subarray formed by the first end[i] elements of the permutation must contain exactly cnt[i] inversions.
An inversion in a permutation is defined as a pair of indices (i,j) such that i<j and perm[i]>perm[j].

The king has tasked Sage Inversius to count the number of valid permutations of the array [0,1,2,...,n−1] that satisfy all these inversion requirements. Knowing that the number of such permutations could be astronomically large, the king requests the answer to be given modulo 10^9 + 7.

Input:

A integer len.
A vector of vector of integer requirements.


Constraints:

len : The length of the vector to be permuted is between 2 and 300, inclusive.
requirements :
There is at least one inversion requirement and at most n inversion requirements.
Each requirement is represented as a pair where end[i] is an index and cnt[i] is the number of required inversions in the subarray.
The end index of the subarray for each requirement ranges from 0 to len−1, inclusive.
The number of inversions required in the subarray ranges from 0 to 400, inclusive.
There is at least one requirement that involves the entire array.
Each requirement has a distinct end index.

Output:

A integer answer which denotes the count of permutation with given requirements.


*/
