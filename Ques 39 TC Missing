// https://www.geeksforgeeks.org/maximize-length-of-longest-subarray-consisting-of-same-elements-by-at-most-k-decrements/

// Write a function LongestSubArray that find the longest subarray where all elements are equal after decrementing atmost k times.

// In the land of Numerica, there lived a curious mathematician named Euler. He loved to solve puzzles involving numbers and arrays. One day, Euler discovered an intriguing challenge and decided to share it with his fellow Numericans.

// "Imagine," he began, "that you have an array of numbers, each representing a magical element. This array, which we'll call arr, contains N elements. Now, suppose you have a special power: the ability to decrement any element in the array by 1. But this power is limitedâ€”you can only use it K times in total."

// Euler continued, "The goal is to use your power wisely to transform the array such that you create the longest possible subarray where all elements are the same. This subarray must be contiguous, meaning all its elements are next to each other without any gaps."

// He presented the challenge to the Numericans in the form of a task:

// The Task:

// Given an array arr[] of size N and an integer K, determine the length of the longest subarray consisting of the same elements that can be obtained by decrementing the array elements by 1 at most K times.
// Example:
// Imagine you have the array arr = [3, 1, 2, 1, 1, 1, 3, 3] and K = 3. By decrementing some of the elements, you could transform a part of the array to create a subarray where all elements are the same. The goal is to find the length of the longest such subarray.



// Input :

// A vector of integer arr.
// A integer decrements.

// Output :

// An integer ans the longest subarray where all elements are equal after decrementing atmost k times.

// Constraints :

// arr : it ranges from 1 to 100005.
// arr[i] : it ranges from 1 to 1000000000 inclusive.
// decrements : it ranges from 1 to 1000000000 inclusive.


#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

int Build(int segment_tree[], std::vector<int> &arr, int start, int end, int node) {
    if (start == end) {
        segment_tree[node] = arr[start];
        return segment_tree[node];
    }

    int mid = (start + end) / 2;
    int left_min = Build(segment_tree, arr, start, mid, 2 * node + 1);
    int right_min = Build(segment_tree, arr, mid + 1, end, 2 * node + 2);

    return segment_tree[node] = std::min(left_min, right_min);
}

int Query(int segment_tree[], int start, int end, int left, int right, int node) {
    if (start > right || end < left)
        return INT_MAX;

    if (start >= left && end <= right)
        return segment_tree[node];

    int mid = (start + end) / 2;
    int left_min = Query(segment_tree, start, mid, left, right, 2 * node + 1);
    int right_min = Query(segment_tree, mid + 1, end, left, right, 2 * node + 2);

    return std::min(left_min, right_min);
}

int LongestSubarray(std::vector<int> &arr, int decrements) {
    int length = arr.size();
    const int MAX_N = 1e5;
    const int MAX_VAL = 1e9;

    if (length > MAX_N) {
        throw std::invalid_argument("arr length exceeds the maximum allowed limit of 1e5.");
    }
    if (decrements < 1 || decrements > MAX_VAL) {
        throw std::invalid_argument("Number of decrements is out of allowed range (1 to 1e9).");
    }
    for (int i = 0; i < length; i++) {
        if (arr[i] < 1 || arr[i] > MAX_VAL) {
            throw std::invalid_argument("arr element is out of allowed range (1 to 1e9).");
        }
    }

    int result = 1;
    std::vector<int> prefix_sum(length + 1);

    prefix_sum[0] = arr[0];
    for (int i = 0; i < length; i++)
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];

    std::vector<int> segment_tree(4 * length + 5);
    Build(segment_tree.data(), arr, 0, length - 1, 0);

    for (int i = 0; i < length; i++) {
        int start = i;
        int end = length - 1;
        int mid;
        int max_index = i;

        while (start <= end) {
            mid = (start + end) / 2;
            int min_element = Query(segment_tree.data(), 0, length - 1, i, mid, 0);
            int expected_sum = (mid - i + 1) * min_element;
            int actual_sum = prefix_sum[mid + 1] - prefix_sum[i];

            if (actual_sum - expected_sum <= decrements) {
                start = mid + 1;
                max_index = std::max(max_index, mid);
            } else {
                end = mid - 1;
            }
        }

        result = std::max(result, max_index - i + 1);
    }

    return result;
}
