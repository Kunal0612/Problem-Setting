// https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/description/

// Write a function FindIntegers that takes in a positive integer n and returns the number of integers between 0 and n (inclusive) whose binary representations do not contain consecutive ones.

// Once upon a time, in the mystical land of Binaryonia, there lived a wise wizard named Eldrion. Eldrion had a fascination with binary numbers, especially those without consecutive ones in their representation.

// One day, he posed a challenge to the young villagers: "How many numbers between 0 and a given number n (inclusive) can you find whose binary representations do not contain consecutive ones?"

// The villagers were perplexed but intrigued by the wizard's challenge. They knew that a binary number is a number expressed in the base-2 numeral system, consisting only of the digits 0 and 1. For example, the number 5 in binary is 101.

// To solve Eldrion's challenge, they needed to count all the binary numbers from 0 to n that had no consecutive ones in their binary representation. For instance, the number 5 (which is 101 in binary) does not qualify because it has consecutive ones.

// Can you help the villagers solve this mystical problem and impress Eldrion with your computational prowess?

// Input :

// An integer num.

// Output :

// An integer ans the number of the integers in the range [0, num] whose binary representations do not contain consecutive ones.

// Constraints :

// num : it ranges from 1 to 1000000000 inclusive.

#include <string>
#include <algorithm>
#include <cstring>
#include <iostream>

class Solution
{
public:
    long long int Helper(long long int index, bool has_consecutive_ones, std::string &binary_string, int previous_digit, long long int dpp[][3][3])
    {
        if (index >= binary_string.size())
            return 1;
        if (dpp[index][has_consecutive_ones][previous_digit] != -1)
            return dpp[index][has_consecutive_ones][previous_digit];

        long long int count = 0;

        if (has_consecutive_ones)
        {
            if (binary_string[index] == '1')
            {
                if (previous_digit == 0)
                {
                    count += Helper(index + 1, has_consecutive_ones, binary_string, binary_string[index] - '0', dpp);
                }
                count += Helper(index + 1, false, binary_string, 0, dpp);
            }
            else
            {
                count += Helper(index + 1, has_consecutive_ones, binary_string, binary_string[index] - '0', dpp);
            }
        }
        else
        {
            if (previous_digit == 0)
                count += Helper(index + 1, false, binary_string, 1, dpp);
            count += Helper(index + 1, false, binary_string, 0, dpp);
        }

        return dpp[index][has_consecutive_ones][previous_digit] = count;
    }

    int FindIntegers(int num)
    {
        if (num < 2 and num > 1000000000)
        {
            throw std::invalid_argument("Invalid n");
        }

        std::string binary_string = "";

        while (num > 0)
        {
            if (num & 1)
                binary_string += "1";
            else
                binary_string += "0";
            num /= 2;
        }

        std::reverse(binary_string.begin(), binary_string.end());

        long long int dpp[32][3][3];
        std::memset(dpp, -1, sizeof(dpp));

        int ans = Helper(0, true, binary_string, 0, dpp);
        return ans;
    }
};
