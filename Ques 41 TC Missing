// https://leetcode.com/problems/find-maximum-non-decreasing-array-length/description/

// Write a function FindMaximumLength that find the maximum length of a non-decreasing array that can be achieved after performing the operations.

// In a magical land, you are given a 0-indexed integer array called nums. Using your magical powers, you can perform an unlimited number of operations to transform this array. Each operation involves selecting a subarray (a contiguous, non-empty sequence of elements within nums) and replacing it with the sum of its elements. For example, if the given array is [1, 3, 5, 6] and you select the subarray [3, 5], the array will transform into [1, 8, 6].

// Your ultimate goal is to transform the array into the longest possible non-decreasing sequence. A non-decreasing sequence is one in which each element is greater than or equal to the previous element.

// Task:
// Determine and return the maximum length of a non-decreasing array that can be achieved after performing the operations.

// Input:

// A vector of integers nums.

// Output:

// An integer representing the maximum length of a non-decreasing array that can be achieved.

// Constraints:

// The length of nums (len) is between 1 and 100000, inclusive.

// Each element in nums is between 1 and 100000, inclusive.

#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <stdexcept>
#include <climits>

template <class Tree>
class Segtree
{
private:
    long long INF = LONG_LONG_MAX - 1;
    const Tree DEFAULT = INF / 2;
    std::vector<Tree> segtree;
    int len;

public:
    Segtree(int len) : len(len), segtree(len * 2, DEFAULT) {}

    void Set(int ind, Tree val)
    {
        ind += len;
        segtree[ind] = val;
        for (; ind > 1; ind /= 2)
        {
            segtree[ind / 2] = std::min(segtree[ind], segtree[ind ^ 1]);
        }
    }

    Tree Rmin(int start, int end)
    {
        Tree sum = DEFAULT;
        for (start += len, end += len; start < end; start /= 2, end /= 2)
        {
            if (start % 2 == 1)
            {
                sum = std::min(sum, segtree[start++]);
            }
            if (end % 2 == 1)
            {
                sum = std::min(sum, segtree[--end]);
            }
        }
        return sum;
    }
};

int FindMaximumLength(std::vector<int> &array)
{
    int len = array.size();
    if (len < 2 || len > 2 * 10000)
    {
        throw std::invalid_argument("Invalid number of nodes. Must be between 2 and 2*10^4.");
    }

    for (const auto &val : array)
    {
        if (std::abs(val) < 1 || std::abs(val) > 10000)
        {
            throw std::invalid_argument("Invalid array value. Each value must be between 1 and 10^4.");
        }
    }

    long long prefix_sum[(int)1e5 + 3];
    int last[(int)1e5 + 3];
    int ans[(int)1e5 + 3];
    long long INF = LONG_LONG_MAX - 1;
    Segtree<long long> aux(len + 1);
    prefix_sum[0] = 0;
    for (int i = 0; i < len; ++i)
    {
        prefix_sum[i + 1] = prefix_sum[i] + array[i];
        aux.Set(i + 1, INF / 2);
    }

    last[0] = 0;
    ans[0] = 0;
    aux.Set(0, 0);

    for (int i = 1; i <= len; ++i)
    {
        long long current_sum = prefix_sum[i];
        int left = 0;
        int right = i - 1;
        while ((right - left) > 1)
        {
            int m = (right + left) >> 1;
            if (aux.Rmin(m, i) <= current_sum)
                left = m;
            else
                right = m - 1;
        }
        int j = left;
        if (aux.Rmin(right, i) <= current_sum)
            j = right;

        ans[i] = 1 + ans[j];
        last[i] = prefix_sum[i] - prefix_sum[j];
        aux.Set(i, last[i] + prefix_sum[i]);
    }
    return ans[len];
}

int main()
{
    

    return 0;
}
