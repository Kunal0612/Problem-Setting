
/*

https://codeforces.com/problemset/problem/1945/H

Create a C++ function named GCDIsGreater to find the answer vector.

In the evenings during their hike, Kirill and Anton found themselves a unique way to unwind and engage in friendly competition. Nestled in the serenity of nature, they would take out an array of integers nums from their backpack and play a challenging game with it. Here's how their game unfolded:

The Game Rules

Selection Phase:

Kirill's Move: Kirill begins by selecting and encircling a subset of the integers in red. He can choose any number of integers from 2 to nâˆ’2 (where n is the length of the array).
Anton's Move: Anton then encircles all the remaining integers in blue.

Calculation Phase:

Kirill's Calculation: Kirill calculates the Greatest Common Divisor (GCD) of all the integers he encircled in red.
Anton's Calculation: Anton performs a bitwise AND operation on all the integers he encircled in blue and then adds a given number x to the result.

Winning Condition:

Kirill wins if the GCD of his red numbers is strictly greater than the sum of the bitwise AND of Anton's blue numbers and the number val.
Otherwise, Anton wins.

The Challenge

Kirill and Anton pondered over various strategies to outwit each other. Kirill wondered if there was a surefire way to ensure his victory, while Anton, with his knack for bitwise operations, was confident in his approach. The game became an intriguing puzzle:

Kirill's Goal: To choose such red numbers that their GCD is as large as possible.
Anton's Goal: To minimize the GCD of Kirill's red numbers by making the sum of his bitwise AND result and val as large as possible.

Objective

Help Kirill determine if there is a way to always win against Anton. If there is, explain the strategy he should use. If not, provide a reasoning as to why it's impossible.

The game not only tested their mathematical prowess but also their strategic thinking, turning a simple array of integers into a battlefield of wits and tactics.

Input:

A vector of long long integers nums.
An integer val.

Constraints:

nums.size() : ranges from 4 to 400000.
val : ranges from 0 to 400000.
nums : ranges from 1 to 400000


Output:

A vector of integers answer if there is a possible answer else return an empty vector.

*/

#include <iostream>
#include <vector>
#include <algorithm>

void coutYES(const std::vector<int>& src, int n, int fId, int sId) {
    std::cout << "YES\n";
    std::cout << "2 " << src[fId] << ' ' << src[sId] << '\n';
    std::cout << n - 2 << ' ';
    for (int i = 0; i < n; i++) {
        if (i == fId || i == sId) {
            continue;
        }
        std::cout << src[i] << ' ';
    }
    std::cout << '\n';
}

void solve() {
    const int BITS = 20;
    int n, x;
    std::cin >> n >> x;

    std::vector<int> src(n);
    std::vector<std::vector<int>> bitCnt(BITS);

    int maxA = 1;
    for (int i = 0; i < n; i++) {
        std::cin >> src[i];
        maxA = std::max(maxA, src[i] + 1);
        for (int bit = 0; bit < BITS; bit++) {
            if ((1 << bit) & src[i]) {
                continue;
            }
            bitCnt[bit].push_back(i);
        }
    }

    std::vector<bool> incr(n, false);
    std::vector<int> cnt(maxA, 0);
    std::vector<int> divBy(maxA, 0);

    std::vector<int> pref(n);
    std::vector<int> suf(n);

    pref[0] = src[0];
    for (int i = 1; i < n; i++) {
        pref[i] = pref[i - 1] & src[i];
    }

    suf[n - 1] = src[n - 1];
    for (int i = n - 2; i >= 0; i--) {
        suf[i] = suf[i + 1] & src[i];
    }

    for (const auto& item : bitCnt) {
        if (item.size() <= 2) {
            for (const int& id : item) {
                incr[id] = true;
                int myAnd = -1;
                for (int j = id + 1; j < n; j++) {
                    int curAND = (1 << BITS) - 1;
                    if (j + 1 < n) curAND &= suf[j + 1];
                    if (id - 1 >= 0) curAND &= pref[id - 1];
                    if (myAnd != -1) curAND &= myAnd;

                    if (curAND + x < std::__gcd(src[id], src[j])) {
                        coutYES(src, n, id, j);
                        return;
                    }

                    if (myAnd == -1) {
                        myAnd = src[j];
                    } else {
                        myAnd &= src[j];
                    }
                }

                myAnd = -1;
                for (int j = id - 1; j >= 0; j--) {
                    int curAND = (1 << BITS) - 1;

                    if (j - 1 >= 0) curAND &= pref[j - 1];
                    if (id + 1 < n) curAND &= suf[id + 1];
                    if (myAnd != -1) curAND &= myAnd;

                    if (curAND + x < std::__gcd(src[id], src[j])) {
                        coutYES(src, n, id, j);
                        return;
                    }

                    if (myAnd == -1) {
                        myAnd = src[j];
                    } else {
                        myAnd &= src[j];
                    }
                }
            }
        }
    }

    int AND = (1 << BITS) - 1;
    for (int i = 0; i < BITS; i++) {
        if (!bitCnt[i].empty()) {
            AND ^= (1 << i);
        }
    }

    for (int i = 0; i < n; i++) {
        if (!incr[i]) {
            ++cnt[src[i]];
        }
    }

    for (int i = 1; i < maxA; i++) {
        for (int j = i; j < maxA; j += i) {
            divBy[i] += cnt[j];
        }
    }

    for (int g = maxA - 1; g > AND + x; g--) {
        if (divBy[g] < 2) {
            continue;
        }

        int fId = -1;
        int sId = -1;
        for (int i = 0; i < n; i++) {
            if (!incr[i]) {
                if (src[i] % g == 0) {
                    if (fId == -1) {
                        fId = i;
                    } else {
                        sId = i;
                    }
                }
            }
        }
        coutYES(src, n, fId, sId);
        return;
    }

    std::cout << "NO\n";
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int testN;
    std::cin >> testN;
    while (testN--) {
        solve();
    }
    return 0;
}
