/*

https://codeforces.com/problemset/problem/1905/F

Create a C++ function named MaximumValue an answer ie the maximum value of f(p) after performing the operation exactly once

In the enchanted land of Permutania, there lived a brilliant strategist named Sir Regulus. The wise King of Permutania, impressed by Sir Regulus's talents, entrusted him with a unique and challenging task involving a special array of numbers.

This array, called P, was a permutation of length n. This means it was an array consisting of n distinct integers from 1 to n arranged in a unique order. For example, [2, 3, 1, 5, 4] was a permutation, but [1, 2, 2] was not, since the number 2 appeared twice.

Sir Regulus was to identify the "good" indices in this permutation. An index x was considered good if:

For all indices y less than x, nums[y]>nums[x]
â€‹
For all indices y greater than x, nums[y]>nums[x]
 
In simpler terms, nums_x was the largest value up to that point in the array, and it was the smallest value from that point onward.

The King defined f(P) as the number of good indices in the permutation P. But there was a twist: Sir Regulus could perform exactly one swap operation, where he could choose any two distinct indices i and j and swap the elements at these positions, nums_i and nums_j.

The challenge was to find the maximum value of f(P) after performing exactly one swap operation.

Sir Regulus pondered over the permutation, considering all possible swaps to determine how they would affect the number of good indices. The task required not only a keen eye for detail but also a deep understanding of how each swap would alter the array's structure.

Would you be able to assist Sir Regulus in this intricate quest? By analyzing the permutation and strategically choosing the best swap, you could help maximize the number of good indices and ensure Sir Regulus's success in his mission.

Embark on this mathematical journey and uncover the optimal strategy for finding the maximum number of good indices!

Input:

A vector of integers nums.

Constraints:

nums.size() : ranges from 1 to 100000.
nums : ranges from 1 to nums.size().

Output:

An integer answer ie the maximum value of f(p) after performing the operation exactly once.


*/
